\chapter{Umsetzung}

In diesem Kapitel wird die Umsetzung der Software, sprich der App betrachtet. Die weiteren Abschnitte gliedern sich nach Anforderungen, welche an die App gestellt werden, und der daraus resultierenden Implementierung dieser Anforderungen. Desweiteren wird auf Probleme bei der Umsetzung näher eingegangen.

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Anforderungen}

Das Ziel ist es, eine Software in App-Form zu entwickeln, welche Bandbreitenmessungen unter zu Hilfenahme von unterschiedlichen Messmethoden durchführt. Zu diesem Zweck sollte die Software in der Lage sein automatisiert Messungen in bestimmten zeitlichen Abständen vorzunehmen. Darüber hinaus sollen die Messergebnisse permanent auf einem Server abgespeichert werden. Zur besseren Transparenz sollen die erfassten Daten des Gerätes dem Benutzer sichtbar gemacht werden.
\\\\
Für die in der App verwendeten Messmethoden gelten separate Anforderungen, die im Folgenden getrennt von den Anforderungen der App beschrieben werden.

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Messmethoden}

Da die Messmethoden im mobilen Bereich Verwendung finden, müssen diese spezielle Anforderungen erfüllen. Eine der wichtigsten ist die des verwendeten Datenvolumen. Da Datenvolumen im mobilen Bereich für die meisten Geräte beziehungsweise Nutzer begrenzt ist, sollten die Messmethoden möglichst wenig Daten pro Messung benötigen. Desweiteren ist die Präzision ein wichtiges Kriterium. Pro Messung sollte jedes Verfahren ein möglichst präzises Ergebnis ermitteln. Die Präzision leidet meistens unter dem verringerten Datenvolumen. Deswegen ist es wichtig, dass zwischen diesen beiden Anforderungen der passende Kompromiss gefunden wird. Desweiteren ist die Zeitdauer der Messung entscheidend. Diese sollte auf keinen Fall zu lang sein, da sich mobile Geräte mitunter schnell bewegen können. 

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{App}

Die Anforderungen an die App beziehen sich auf der einen Seite auf die Funktionen, die in Verbindung mit den Bandbreitenmessungen stehen. Auf der anderen Seite sind es die Einstellungsmöglichkeiten, die dem Benutzer zur Verfügung gestellt werden. Darüber hinaus gibt es Anforderungen die sich auf den Umgang mit Nutzerdaten beziehen.
\\\\
Bei den Anforderungen zur Bandbreitenmessung ist wichtig, dass diese automatisiert ausgeführt werden. Das bedeutet, dass Messvorgänge periodisch  gestartet werden, ohne das der Benutzer aktiv eine Messung ausführen muss. Darüber hinaus ist die manuelle Ausführung eines Messvorgangs aber ebenfalls möglich. Desweiteren sollen die gemessenen Daten an einen Server geschickt werden, um diese auswerten zu können. Das Verschicken der  Daten zum Server sollte nicht nach jedem Messvorgang erfolgen. Die Daten sollen zuerst auf dem Gerät zwischengespeichert werden und innerhalb einer bestimmten Zeitspanne (ein Mal pro Tag) versendet werden. Um einen Überblick über ausgeführte Messvorgänge zu bekommen, werden diese in Listenform mit allen relevanten erfassten Daten angezeigt.
\\
Über die Messdaten zur Bandbreite hinaus, werden weitere Parameter erfasst, die zur Auswertung der Daten nützlich sind. Diese Daten sind in Tabelle \ref{t-collected-userdata} kurz aufgelistet.

\begin{table}[H]
	\centering
		\begin{tabular}{|c|p{11cm}|}
		\hline
			\textbf{Parameter} & \textbf{Bedeutung} \\
		\hline
			Zeitstempel & Datum und Zeit, an der die Messung ausgeführt wurde \\
		\hline
			Wifi & Angabe, ob die Messung über ein WLAN erfolgte \\
		\hline
			Mobile & Angabe, ob die Messung über ein mobiles Netz erfolgte \\
		\hline
			Provider & Verwendeter Telekommunikationsanbieter \\
		\hline
			Country Code & Ländercode zur Identifizierung des Landes \\
		\hline
			MCC & Mobile Country Code - Zur geografischen Zuordnung des Mobilfunknetzes \\
		\hline
			MNC & Mobile Network Code - Zur Identifizierung des Funknetzanbieters \\
		\hline
			LAC & Location Area Code - Aufenthaltsbereich eines Mobiltelefons innerhalb eines Funknetzes \\
		\hline
			CID & Cell Identification - Eine eindeutige Kennzahl für eine Sendestation \\
		\hline
			GPS & Vom Endgerät ermittelte GPS-Koordinaten \\
		\hline
		\end{tabular}
	\caption{Erhobene Nutzerdaten}
	\label{t-collected-userdata}
\end{table}

Bei diesen Daten handelt es sich um sensible Nutzerdaten. Um die Privatsphäre des Nutzers zu schützen, werden diesem Einstellungen zur Verschleierung seiner Daten zur Verfügung gestellt. Diese beziehen sich zum einen auf den erfassten Ort und zum anderen auf die erfasste Zeit. Der Nutzer kann einstellen, dass nicht direkt die GPS-Koordinaten des Gerätes, sondern die des Zugangspunktes erfasst werden. Bei der Zeit kann eingestellt werden, dass diese immer auf eine volle Stunde auf- beziehungsweise abgerundet wird. Um das Mitschneiden der Daten bei der Übertragung vom Gerät zum Server zu verhindern werden diese zusätzlich verschlüsselt übertragen.
\\
Darüber hinaus hat der Nutzer noch weitere Einstellungsmöglichkeiten, um das verwendete Datenvolumen bei den Messungen zu begrenzen. Zum einen kann eingestellt werden, dass Messungen nur im WLAN ausgeführt werden, um das mobile Datenvolumen nicht zu belasten. Zum anderen kann die Anzahl der Messdurchläufe der Messmethoden pro Messungvorgang eingestellt werden.

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Implementierung}

Die Implementierung der Anforderungen für die App kann in drei Abschnitte unterteilt werden, da diese größtenteils unabhängig voneinander umgesetzt wurden. Die drei Abschnitte befassen sich zum einen mit den Messmethoden, die unabhängig von der späteren Verwendung in einer App implementiert wurden und zum anderen mit der eigentlichen Umsetzung der App. Der dritte Abschnitt befasst sich mit der Umsetzung eines Sniffers, sprich eines Programms zur Paketanalyse der Netzwerkpakete.
\\
Desweiteren wird die Umsetzung des Servers beschrieben, sowie die Abspeicherung der Daten.

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Messmethoden}

...

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{\gls{Sniffer}}

Der Sniffer ist zur Erfassung von Datenpaketen des Netzwerkverkehrs. Die Erfassung ist wichtig, da anhand dieser Pakete die genauen Sende- und Empfangszeiten der Pakete ermittelt und daraus die Bandbreiten exakter berechnet werden können.
\\
Aufgrund der Tatsache, dass es in Java auf Socket-Ebene keine Pakete, sondern nur Datenströme gibt, musste der Sniffer in C umgesetzt werden.
Der Sniffer arbeit auf Raw-Socket-Ebene. Dies bedeutet, dass Pakete direkt gesendet oder empfangen werden können, ohne Formatieung von darüber liegenden Transportprotokollen. Der Sniffer ist so implementiert, dass er auf unterschiedliche Protokollarten (TCP, UDP, ICMP, ...) reagieren kann. 
Allerdings werden nur bei TCP-basierten Paketen Ausgaben erzeugt. Diese Ausgaben beschränken sich auf die Quell- und Zieladresse sowie die Größe und den Zeitstempel des Paketes. Als Einschränkung der Ausgaben kann eine IP-Adresse bei Start des Sniffers übergeben werden, sodass nur Paketinformationen zu Paketen ausgegeben werden, bei denen die Quell- oder Zieladresse identisch mit der übergebenen Adresse ist. Eine weitere Einschränkung ist die Paketgröße. Pakete die kleiner als 100 Byte sind, werden nicht ausgegeben. Dies hat den Grund, dass Paketproben der App immer größer als 100 Byte sind und somit für die Berechnung unwichtige Kontrollnachrichten wie Acknowledgements direkt gefiltert werden.
\\\\
Mit dem Native Development Kit (NDK) von Android, welches eine Sammlung von Bilbliotheken zur Verwendung von nativen Programmiersprachen wie C oder C++ ist, kann der Sniffer in der App verwendet werden. Dazu wird der Sniffer-Code mit Hilfe des NDK kompiliert und die kompilierte Datei des Sniffers wird im entsprechenden Ordner der App für zusätzliche Dateien hinterlegt. Der Code wird bei Nutzung der App aus diesem Ordner kopiert und verwendet.

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{App}

Die wesentlichen Informationen einer App werden über eine Manifest-Datei dem System bekannt gemacht. Zu diesen Informationen zählt zum einen die minimale Android-Version unter der die App noch reibungslos funktioniert sowie die Version, für die die App konzipiert wird. Darüber hinaus stehen in der Manifest-Datei die Komponenten, aus der die App besteht. Die App besteht aus den drei wesentlichen Komponenten Aktivität, BroadcastReceiver und Service.
\\\\
\textbf{Aktivität}
\\
Eine Aktivität beschreibt eine einzelne Sicht einer App. Eine Aktivität hat einen Lebenszyklus der die verschiedenen Stadien beschreibt, in der sich eine App befinden kann. Anhand des Lebenszyklus können in den verschiedenen Stadien entsprechende Aktionen ausgeführt werden.
\\\\
\textbf{BroadcastReceiver}
\\
Der BroadcastReceiver empfängt Nachrichten, welche vom System oder anderen Apps verschickt werden. Diese Nachrichten können zum Beispiel angeben, dass die Batterieleistung niedrig ist, oder der Bildschirm ausgeschaltet wurde.
\\\\
\textbf{Service}
\\
Ein Service ist ein Prozess, welcher im Hintergrund ausgeführt wird. Dies ist von Vorteil bei lang andauernden Operationen oder bei sich periodisch wiederholenden Operationen.
\\\\
Neben den Komponenten benötigen viele Apps Berechtigungen, um auf Systemeigenschaften zuzugreifen. 

\begin{table}[H]
	\centering
		\begin{tabular}{|c|p{9cm}|}
		\hline
			\textbf{Berechtigung} & \textbf{Beschreibung}  \\
		\hline
			Internet & Erlaubt Applikationen Sockets zu öffnen  \\
		\hline
			Access\_Network\_State & Erlaubt Applikationen Zugriiff auf Netzwerkinformationen \\
		\hline
			Access\_Wifi\_State & Erlaubt Applikationen Zugriff auf Wifi-Informationen  \\
		\hline
			Access\_Coarse\_Location & Grobe Standortbestimmung über Standort des Funkmasten (Cell-ID) \\
		\hline
			Access\_Fine\_Location & Feine Standortbestimmung über die GPS-Daten des Gerätes \\
		\hline
			Receive\_Boot\_Completed & Erlaubt Applikationen sich selbst auszuführen, nachdem das Telefon gestartet wurde  \\
		\hline
		\end{tabular}
	\caption{Benötigte Berechtigungen der App}
	\label{t-permissions}
\end{table}

Diese Berechtigungen müssen in der Manifest-Datei beschrieben werden. Der Nutzer wird daraufhin bei der Installation der App über diese informiert, und muss zur Nutzung der App diesen Berechtigungen zustimmen. Die Berechtigungen für diese App sind in Tabelle \ref{t-permissions} zusammengefasst. Das Zusammenspiel der einzelnen Komponenten ist in Abbildung \ref{component-overview} schematisch dargestellt und wird im Folgenden erläutert.

\begin{figure}[htbp]
	\centering
		\includegraphics[scale=0.52]{images/App-Component-Overview.png}
		\caption{Schematischer Aufbau der App}
		\label{component-overview}
\end{figure}

Die App ist optisch in zwei Bereiche aufgeteilt, besitzt somit zwei Hauptaktivitäten. Zum einen gibt es die Startaktivität \ref{overview} auf der eine Übersicht mit Statistiken, sowie einer Nachrichtenkonsole und der Steuerung angezeigt wird. Darüber hinaus gibt es eine Ergebnisaktivität \ref{resultsview}, in der die Messergebnisse in ausklappbaren Listen angezeigt werden. Zusätzlich zu den beiden Aktivitäten gibt es eine Einstellungsaktivität \ref{settingsview} über die der Benutzer die Rahmenbedingungen für die Messungen einstellen kann.

\begin{figure}[htbp]
\begin{minipage}[hbt]{0,325\textwidth}
	\centering
		\includegraphics[scale=0.11]{images/App-Overview.png}
		\caption{Startaktivität}
		\label{overview}
\end{minipage}
\begin{minipage}[hbt]{0,325\textwidth}
	\centering
		\includegraphics[scale=0.11]{images/App-Resultsview.png}
		\caption{Ergebnisaktivität}
		\label{resultsview}
\end{minipage}
\begin{minipage}[hbt]{0,325\textwidth}
	\centering
		\includegraphics[scale=0.11]{images/App-Settingsview.png}
		\caption{Einstellungsaktivität}
		\label{settingsview}
\end{minipage}
\end{figure}

Das Umschalten zwischen den Aktivitäten erfolgt über die Schaltflächen am unteren Rand jeder Sicht ausgenommen die Einstellungsaktivität. Diese wird über das Symbol am oberen rechten Rand aus den beiden anderen Aktivitäten aufgerufen. Die Startaktivität hat drei zusätzliche Schaltflächen, über die Messungen gestartet und gestoppt werden können. Es kann eine einzelne Messung oder die Automatik über eine Schaltfläche gestartet werden. Die Automatik führt in bestimmten zeitlichen Abständen die Messungen durch. Diese kann durch die dritte Schaltfläche jederzeit beendet werden.
\\\\
Der Lebenszyklus der Startaktivität ist wichtig, da somit alle wichtigen Funktionen der App initialisiert werden. Zum besseren Verständnis des Lebenszyklus ist dieser in Abbildung \ref{process-diagramm} dargestellt. 

\begin{figure}[H]
	\centering
		\includegraphics[scale=0.6]{images/activity-lifecycle.png}
		\caption[\url{https://developer.android.com/images/training/basics/basic-lifecycle.png}]{Lebenszyklus einer Aktivität}
		\label{activity-lifecycle}
\end{figure}

Der Lebenszklus umfasst viele Stadien, wovon die Methoden onCreate(), onStop() und onDestroy() entscheidend für diese App sind.
\\\\
\textbf{onCreate()}
\\
In dieser Methode werden alle grafischen Elemente der Hauptaktivität initialisiert. Dies gilt im Übrigen auch für die onCreate()-Methoden der anderen Aktivitäten. Darüber hinaus wird bei der Methode der Hauptaktivität zusätzlich noch abgefragt, ob Root-Rechte vorliegen. Dies ist wichtig für den nächsten Schritt der Methode. Dort werden Operationen ausgeführt, die den Sniffer betreffen, welcher nur mit Root-Rechten gestartet werden kann. Erster Schritt bei der Verwendung des Sniffers ist es, den kompilierten Code aus dem App-Ordner zu kopieren, da er dort nicht ausgeführt werden kann. Der Code wird stattdessen in den internen Speicherort der App kopiert, wo er ausgeführt werden kann. Wenn dies erledigt ist, wird der Sniffer über einen in Java initialisierten Prozess ausgeführt. Dies funktioniert, da mit Hilfe dieses Prozess Kommandozeilen-Befehle ausgeführt werden können.
\\\\
\textbf{onStop()}
\\
In dieser Methode werden die gesammelten Ergebnisse gespeichert. Wenn die App geöffnet ist, werden die Ergebnisse vorerst temporär im Datenmodell festgehalten, um nicht bei jeder Messung Daten ins Dateisystem zu schreiben. Wenn die App angehalten wird, werden vorher alle bis dahin gesammelten Ergebnisse in eine Datei gespeichert. Die Daten werden dabei nicht in der onDestroy()-Methode gespeichert, da es passieren kann, dass diese Methode nicht aufgerufen wird.
\\\\
\textbf{onDestroy()}
\\
In dieser Methode wird der laufende Service beendet. Wenn die App gerade in einer laufenden Messung ist und beendet wird, wird der Service für die laufende Messung ebenfalls beendet, egal ob es eine einmalige Messung, oder die automatische Messung ist.
\\\\
Der BroadcastReceiver der App ist zur Erkennung, dass das Telefon gestartet wurde. Dies ist nötig, damit die automatische Messung auch nach Neustart des Telefons aktiv bleibt. Ebenso wird darüber auch die automatische Messung gestartet. Der BroadcastReceiver initialisiert einen AlarmManager. Ein AlarmManager ist eine Systemressource und mittels dieser kann zu einem bestimmten Zeitpunkt oder auch periodisch ein Service gestartet werden. Der AlarmManager wird so initialisiert, dass er periodisch einen Service startet. Dies wird solange fortgesetzt, bis die Automatik der App vom Benutzer ausgeschaltet wird.
\\\\
Der Service der App misst die Bandbreite. Der schematische Ablauf des Services ist in Abbildung \ref{process-diagramm} dargestellt. 

\begin{figure}[htbp]
	\centering
		\includegraphics[scale=0.6]{images/Process-Diagramm.png}
		\caption{Schematischer Ablauf einer Messung}
		\label{process-diagramm}
\end{figure}

Der Service wird periodisch durch den Alarm oder aber einmalig durch den Benutzer ausgelöst. Nach erfolgreicher Messung beendet sich der Service, damit er nicht im Speicher bleibt und Ressourcen verschwendet. Bevor die eigentliche Messung gestartet wird, startet der Service den Sniffer, um Pakete empfangen zu können. Dieser wird beendet, nachdem die Messungen ausgeführt wurden. Die vom Sniffer empfangenen Pakete werden nach Ausführung der eigentlichen Messung ausgewertet. Bei geöffneter App werden die Ergebnisse temporär im Datenmodell gespeichert und die entsprechenden Aktivitäten über einen weiteren BroadcastReceiver vom Service über Aktualisierungen informiert. Bei geschlossener App wird das Ergebnis in eine Datei gespeichert bevor der Service beendet wird.

Die Datenspeicherung erfolgt temporär in einem Datenmodell. Das Datenmodell besteht im Wesentlichen aus drei Klassen, die in Abbildung \ref{classdiagram-model} dargestellt sind. 

\begin{figure}[htbp]
	\centering
		\includegraphics[scale=0.9]{images/Classdiagram-Model.png}
		\caption{Klassendiagramm Datenmodell}
		\label{classdiagram-model}
\end{figure}

Die Objekte der Klasse Bandwidths beinhalten die konkreten Bandbreitenmessungen, sowie die Bezeichnung für die jeweilige Messmethode. Die Klasse Results repräsentiert alle Daten eines einzelnen Messvorgangs. Ein Objekt dieser Klasse speichert neben einer Anzahl n an Bandwidths-Objekten weitere wichtige Parameter, welche in Tabelle \ref{t-collected-userdata} bereits erläutert wurden.
\\\\
Um die Messdaten persistent abzuspeichern werden diese im internen Speicher des Telefons als Datei abgespeichert. Dafür werden die Informationen der Results-Objekte in JSON formatiert und abgespeichert. Die vorgenommenen Einstellungen des Benutzers und andere kleinere Daten werden mit Hilfe der von Android standardmäßig implementierten Klasse SharedPreferences gespeichert. Mittels dieser Klasse lassen sich nur einfache Datenstrukturen abspeichern sodass diese Klasse zur Speicherung der Results-Objekte nicht geeignet ist. Die Informationen werden ebenfalls als Datei im internen Speicher des Telefons im xml-Format abgelegt.
\\\\
Die abgespeicherten Daten werden einmal pro Tag an den Server gesendet. Dabei wird wieder ein Service verwendet. Dieser wird ebenfalls über einen AlarmManager gestartet. Der Service läd die Daten aus der gespeicherten Datei und sendet diese an den Server. Der Server antwortet ob die Daten gespeichert wurden, oder nicht. Wenn der Server die Speicherung bestätigt, werden die Daten vom Gerät gelöscht.

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsection{Server}

Der Server hat zwei Hauptfunktionen. Zum einen werden über den Server Pakete zur Bandbreitenbestimmung ausgetauscht und zum anderen ist dieser zuständig für die Speicherung der zugesendeten Daten der einzelnen Geräte. Da sich prinzipiell Clients beliebiger Anzahl gleichzeitig mit dem Server verbinden können, ist dieser so ausgelegt, dass die einzelnen akzeptierten Verbindungen an Threads ausgelagert werden. Um die Verbindungsgrenze nach oben hin zu limitieren wird ein ThreadPoolExecutor verwendet. Mittels dieser von Java bereitgestellten Klasse lassen sich Threads effizient parallelisieren. Zusätzliche Funktionen beschränken unter anderem die maximale Anzahl an Threads.
\\\\
Die mit einem Client verbundenen Threads reagieren auf unterschiedliche Nachrichtentypen, sodass auf die jeweilige Messmethode passend reagiert werden kann. Aus diesem Grund verwendet der Client bei Anfrage für eine Messmethode eine Zeichenfolge, damit die Gegenseite die entsprechenden Pakete zurücksenden kann. Gleiches passiert bei der Datenspeicherung. Der Client sendet vor den eigentlichen Daten eine Zeichenfolge, damit der Server erkennt, dass Daten zur Abspeicherung folgen. Die Daten werden mit Hilfe von JDBC (Java Database Connectivity) in eine Datenbank gespeichert. JDBC ist eine Schnittstelle und bietet Funktionen zur Verbindung mit Datenbanken unterschiedlicher Hersteller.

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\subsubsection{Datenbank}

Zur persistenten Datenspeicherung wird eine PostgreSQL Datenbank verwendet. Die Entscheidung für diese Datenbank wurde auf Grundlage der Erweiterung PostGIS für diese Datenbank gewählt. PostGIS ist eine Erweiterung die geografische Objekte und Funktionen umfasst. Mit Hilfe dieser Erweiterung können die gesammelten geograpfischen Koordinaten der einzelnen Geräte somit grafisch dargestellt werden.
\\\\
Die Daten werden in zwei Tabellen abgespeichert. Die Tabellen repräsentieren die Klassen des Datenmodells Results und Bandwidths.

%-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

\section{Probleme}

Die Umsetzung der Idee Bandbreitenmessmethoden auf mobilen Endgeräten zu verwenden, brachte mehrere Probleme hervor, die in diesem Kapitel näher betrachtet werden. 
\\
Das Hauptproblem bei der Umsetzung liegt hauptsächlich bei der verwendeten Programmiersprache Java. Java ist eine höhere Programmiersprache. Aus diesem Grund können hardwarenahe Funktionen nicht direkt oder gar nicht ausgeführt werden. Dies macht sich bei Verwendung von Sockets direkt bemerkbar. Bei Java basiert die Versendung von Daten über Sockets auf Datenströmen. Die tatsächliche Datenversendung im Rechnernetz erfolgt allerdings paketvermittelt, sprich Daten werden in einzelnen Paketen versendet. Auf dieser Grundlage ist es in Java nicht möglich einzelne Pakete zu verschicken, oder Ankunftszeiten einzelner Pakete direkt aus Java heraus zu ermitteln.
\\
Als Problemlösung bietet sich die Verwendung von Drittanbieterbibliotheken an, welche diese Funktionen in Java bereitstellen (JnetPcap, RawSocket). Die Funktionen die in Java zur Verfügung stehen, werden am Ende auf hardware-nähere Programmiersprachen wie C abgebildet. Das Problem bei diesen Bibliotheken ist allerdings die Verwendung unter Android. Das Problem ergibt sich daraus, dass Paketinformationen nur über Raw-Sockets bezogen werden können. Unter Android können nur Systemapps die Erlaubnis beziehen auf Raw-Sockets zuzugreifen. Aus diesem Grund können die Bibliotheken zwar unter Android verwendet werden, die Ausführung der Funktionen ist allerdings nicht möglich.
\\
Die Ermittlung der Ankunftszeiten kann in Java über die Messung der Systemzeit vor Datenempfang erfasst werden. Diese Zeit kann allerdings mehr oder weniger stark von der tatsächlichen Ankunftszeit der Pakete an der Netzwerkschnittstelle abweichen, da zwischen dem Empfang an der Schnittstelle und der ermittelten Systemzeit in Java mehrere Transportschichten liegen, die das Paket noch durchlaufen muss.